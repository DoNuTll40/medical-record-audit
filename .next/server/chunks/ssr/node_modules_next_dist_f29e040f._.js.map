{"version":3,"sources":["turbopack:///[project]/node_modules/next/src/server/lib/trace/constants.ts","turbopack:///[project]/node_modules/next/src/shared/lib/is-thenable.ts","turbopack:///[project]/node_modules/next/src/server/lib/trace/tracer.ts","turbopack:///[project]/node_modules/next/src/client/components/hooks-server-context.ts","turbopack:///[project]/node_modules/next/src/client/components/static-generation-bailout.ts","turbopack:///[project]/node_modules/next/src/server/dynamic-rendering-utils.ts","turbopack:///[project]/node_modules/next/src/lib/framework/boundary-constants.tsx","turbopack:///[project]/node_modules/next/src/lib/scheduler.ts","turbopack:///[project]/node_modules/next/src/shared/lib/lazy-dynamic/bailout-to-csr.ts","turbopack:///[project]/node_modules/next/src/shared/lib/invariant-error.ts","turbopack:///[project]/node_modules/next/src/server/app-render/dynamic-rendering.ts","turbopack:///[project]/node_modules/next/src/lib/detached-promise.ts","turbopack:///[project]/node_modules/next/src/server/stream-utils/encoded-tags.ts","turbopack:///[project]/node_modules/next/src/server/stream-utils/uint8array-helpers.ts","turbopack:///[project]/node_modules/next/src/shared/lib/errors/constants.ts","turbopack:///[project]/node_modules/next/src/shared/lib/segment-cache/output-export-prefetch-encoding.ts","turbopack:///[project]/node_modules/next/src/server/stream-utils/node-web-streams-helper.ts","turbopack:///[project]/node_modules/next/src/shared/lib/page-path/ensure-leading-slash.ts","turbopack:///[project]/node_modules/next/src/shared/lib/segment.ts","turbopack:///[project]/node_modules/next/src/shared/lib/router/utils/app-paths.ts"],"sourcesContent":["/**\n * Contains predefined constants for the trace span name in next/server.\n *\n * Currently, next/server/tracer is internal implementation only for tracking\n * next.js's implementation only with known span names defined here.\n **/\n\n// eslint typescript has a bug with TS enums\n/* eslint-disable no-shadow */\n\nenum BaseServerSpan {\n  handleRequest = 'BaseServer.handleRequest',\n  run = 'BaseServer.run',\n  pipe = 'BaseServer.pipe',\n  getStaticHTML = 'BaseServer.getStaticHTML',\n  render = 'BaseServer.render',\n  renderToResponseWithComponents = 'BaseServer.renderToResponseWithComponents',\n  renderToResponse = 'BaseServer.renderToResponse',\n  renderToHTML = 'BaseServer.renderToHTML',\n  renderError = 'BaseServer.renderError',\n  renderErrorToResponse = 'BaseServer.renderErrorToResponse',\n  renderErrorToHTML = 'BaseServer.renderErrorToHTML',\n  render404 = 'BaseServer.render404',\n}\n\nenum LoadComponentsSpan {\n  loadDefaultErrorComponents = 'LoadComponents.loadDefaultErrorComponents',\n  loadComponents = 'LoadComponents.loadComponents',\n}\n\nenum NextServerSpan {\n  getRequestHandler = 'NextServer.getRequestHandler',\n  getServer = 'NextServer.getServer',\n  getServerRequestHandler = 'NextServer.getServerRequestHandler',\n  createServer = 'createServer.createServer',\n}\n\nenum NextNodeServerSpan {\n  compression = 'NextNodeServer.compression',\n  getBuildId = 'NextNodeServer.getBuildId',\n  createComponentTree = 'NextNodeServer.createComponentTree',\n  clientComponentLoading = 'NextNodeServer.clientComponentLoading',\n  getLayoutOrPageModule = 'NextNodeServer.getLayoutOrPageModule',\n  generateStaticRoutes = 'NextNodeServer.generateStaticRoutes',\n  generateFsStaticRoutes = 'NextNodeServer.generateFsStaticRoutes',\n  generatePublicRoutes = 'NextNodeServer.generatePublicRoutes',\n  generateImageRoutes = 'NextNodeServer.generateImageRoutes.route',\n  sendRenderResult = 'NextNodeServer.sendRenderResult',\n  proxyRequest = 'NextNodeServer.proxyRequest',\n  runApi = 'NextNodeServer.runApi',\n  render = 'NextNodeServer.render',\n  renderHTML = 'NextNodeServer.renderHTML',\n  imageOptimizer = 'NextNodeServer.imageOptimizer',\n  getPagePath = 'NextNodeServer.getPagePath',\n  getRoutesManifest = 'NextNodeServer.getRoutesManifest',\n  findPageComponents = 'NextNodeServer.findPageComponents',\n  getFontManifest = 'NextNodeServer.getFontManifest',\n  getServerComponentManifest = 'NextNodeServer.getServerComponentManifest',\n  getRequestHandler = 'NextNodeServer.getRequestHandler',\n  renderToHTML = 'NextNodeServer.renderToHTML',\n  renderError = 'NextNodeServer.renderError',\n  renderErrorToHTML = 'NextNodeServer.renderErrorToHTML',\n  render404 = 'NextNodeServer.render404',\n  startResponse = 'NextNodeServer.startResponse',\n\n  // nested inner span, does not require parent scope name\n  route = 'route',\n  onProxyReq = 'onProxyReq',\n  apiResolver = 'apiResolver',\n  internalFetch = 'internalFetch',\n}\n\nenum StartServerSpan {\n  startServer = 'startServer.startServer',\n}\n\nenum RenderSpan {\n  getServerSideProps = 'Render.getServerSideProps',\n  getStaticProps = 'Render.getStaticProps',\n  renderToString = 'Render.renderToString',\n  renderDocument = 'Render.renderDocument',\n  createBodyResult = 'Render.createBodyResult',\n}\n\nenum AppRenderSpan {\n  renderToString = 'AppRender.renderToString',\n  renderToReadableStream = 'AppRender.renderToReadableStream',\n  getBodyResult = 'AppRender.getBodyResult',\n  fetch = 'AppRender.fetch',\n}\n\nenum RouterSpan {\n  executeRoute = 'Router.executeRoute',\n}\n\nenum NodeSpan {\n  runHandler = 'Node.runHandler',\n}\n\nenum AppRouteRouteHandlersSpan {\n  runHandler = 'AppRouteRouteHandlers.runHandler',\n}\n\nenum ResolveMetadataSpan {\n  generateMetadata = 'ResolveMetadata.generateMetadata',\n  generateViewport = 'ResolveMetadata.generateViewport',\n}\n\nenum MiddlewareSpan {\n  execute = 'Middleware.execute',\n}\n\ntype SpanTypes =\n  | `${BaseServerSpan}`\n  | `${LoadComponentsSpan}`\n  | `${NextServerSpan}`\n  | `${StartServerSpan}`\n  | `${NextNodeServerSpan}`\n  | `${RenderSpan}`\n  | `${RouterSpan}`\n  | `${AppRenderSpan}`\n  | `${NodeSpan}`\n  | `${AppRouteRouteHandlersSpan}`\n  | `${ResolveMetadataSpan}`\n  | `${MiddlewareSpan}`\n\n// This list is used to filter out spans that are not relevant to the user\nexport const NextVanillaSpanAllowlist = [\n  MiddlewareSpan.execute,\n  BaseServerSpan.handleRequest,\n  RenderSpan.getServerSideProps,\n  RenderSpan.getStaticProps,\n  AppRenderSpan.fetch,\n  AppRenderSpan.getBodyResult,\n  RenderSpan.renderDocument,\n  NodeSpan.runHandler,\n  AppRouteRouteHandlersSpan.runHandler,\n  ResolveMetadataSpan.generateMetadata,\n  ResolveMetadataSpan.generateViewport,\n  NextNodeServerSpan.createComponentTree,\n  NextNodeServerSpan.findPageComponents,\n  NextNodeServerSpan.getLayoutOrPageModule,\n  NextNodeServerSpan.startResponse,\n  NextNodeServerSpan.clientComponentLoading,\n]\n\n// These Spans are allowed to be always logged\n// when the otel log prefix env is set\nexport const LogSpanAllowList = [\n  NextNodeServerSpan.findPageComponents,\n  NextNodeServerSpan.createComponentTree,\n  NextNodeServerSpan.clientComponentLoading,\n]\n\nexport {\n  BaseServerSpan,\n  LoadComponentsSpan,\n  NextServerSpan,\n  NextNodeServerSpan,\n  StartServerSpan,\n  RenderSpan,\n  RouterSpan,\n  AppRenderSpan,\n  NodeSpan,\n  AppRouteRouteHandlersSpan,\n  ResolveMetadataSpan,\n  MiddlewareSpan,\n}\n\nexport type { SpanTypes }\n","/**\n * Check to see if a value is Thenable.\n *\n * @param promise the maybe-thenable value\n * @returns true if the value is thenable\n */\nexport function isThenable<T = unknown>(\n  promise: Promise<T> | T\n): promise is Promise<T> {\n  return (\n    promise !== null &&\n    typeof promise === 'object' &&\n    'then' in promise &&\n    typeof promise.then === 'function'\n  )\n}\n","import type { FetchEventResult } from '../../web/types'\nimport type { TextMapSetter } from '@opentelemetry/api'\nimport type { SpanTypes } from './constants'\nimport { LogSpanAllowList, NextVanillaSpanAllowlist } from './constants'\n\nimport type {\n  ContextAPI,\n  Span,\n  SpanOptions,\n  Tracer,\n  AttributeValue,\n  TextMapGetter,\n} from 'next/dist/compiled/@opentelemetry/api'\nimport { isThenable } from '../../../shared/lib/is-thenable'\n\nlet api: typeof import('next/dist/compiled/@opentelemetry/api')\n\n// we want to allow users to use their own version of @opentelemetry/api if they\n// want to, so we try to require it first, and if it fails we fall back to the\n// version that is bundled with Next.js\n// this is because @opentelemetry/api has to be synced with the version of\n// @opentelemetry/tracing that is used, and we don't want to force users to use\n// the version that is bundled with Next.js.\n// the API is ~stable, so this should be fine\nif (process.env.NEXT_RUNTIME === 'edge') {\n  api = require('@opentelemetry/api') as typeof import('@opentelemetry/api')\n} else {\n  try {\n    api = require('@opentelemetry/api') as typeof import('@opentelemetry/api')\n  } catch (err) {\n    api =\n      require('next/dist/compiled/@opentelemetry/api') as typeof import('next/dist/compiled/@opentelemetry/api')\n  }\n}\n\nconst { context, propagation, trace, SpanStatusCode, SpanKind, ROOT_CONTEXT } =\n  api\n\nexport class BubbledError extends Error {\n  constructor(\n    public readonly bubble?: boolean,\n    public readonly result?: FetchEventResult\n  ) {\n    super()\n  }\n}\n\nexport function isBubbledError(error: unknown): error is BubbledError {\n  if (typeof error !== 'object' || error === null) return false\n  return error instanceof BubbledError\n}\n\nconst closeSpanWithError = (span: Span, error?: Error) => {\n  if (isBubbledError(error) && error.bubble) {\n    span.setAttribute('next.bubble', true)\n  } else {\n    if (error) {\n      span.recordException(error)\n      span.setAttribute('error.type', error.name)\n    }\n    span.setStatus({ code: SpanStatusCode.ERROR, message: error?.message })\n  }\n  span.end()\n}\n\ntype TracerSpanOptions = Omit<SpanOptions, 'attributes'> & {\n  parentSpan?: Span\n  spanName?: string\n  attributes?: Partial<Record<AttributeNames, AttributeValue | undefined>>\n  hideSpan?: boolean\n}\n\ninterface NextTracer {\n  getContext(): ContextAPI\n\n  /**\n   * Instruments a function by automatically creating a span activated on its\n   * scope.\n   *\n   * The span will automatically be finished when one of these conditions is\n   * met:\n   *\n   * * The function returns a promise, in which case the span will finish when\n   * the promise is resolved or rejected.\n   * * The function takes a callback as its second parameter, in which case the\n   * span will finish when that callback is called.\n   * * The function doesn't accept a callback and doesn't return a promise, in\n   * which case the span will finish at the end of the function execution.\n   *\n   */\n  trace<T>(\n    type: SpanTypes,\n    fn: (span?: Span, done?: (error?: Error) => any) => Promise<T>\n  ): Promise<T>\n  trace<T>(\n    type: SpanTypes,\n    fn: (span?: Span, done?: (error?: Error) => any) => T\n  ): T\n  trace<T>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: (span?: Span, done?: (error?: Error) => any) => Promise<T>\n  ): Promise<T>\n  trace<T>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: (span?: Span, done?: (error?: Error) => any) => T\n  ): T\n\n  /**\n   * Wrap a function to automatically create a span activated on its\n   * scope when it's called.\n   *\n   * The span will automatically be finished when one of these conditions is\n   * met:\n   *\n   * * The function returns a promise, in which case the span will finish when\n   * the promise is resolved or rejected.\n   * * The function takes a callback as its last parameter, in which case the\n   * span will finish when that callback is called.\n   * * The function doesn't accept a callback and doesn't return a promise, in\n   * which case the span will finish at the end of the function execution.\n   */\n  wrap<T = (...args: Array<any>) => any>(type: SpanTypes, fn: T): T\n  wrap<T = (...args: Array<any>) => any>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: T\n  ): T\n  wrap<T = (...args: Array<any>) => any>(\n    type: SpanTypes,\n    options: (...args: any[]) => TracerSpanOptions,\n    fn: T\n  ): T\n\n  /**\n   * Starts and returns a new Span representing a logical unit of work.\n   *\n   * This method do NOT modify the current Context by default. In result, any inner span will not\n   * automatically set its parent context to the span created by this method unless manually activate\n   * context via `tracer.getContext().with`. `trace`, or `wrap` is generally recommended as it gracefully\n   * handles context activation. (ref: https://github.com/open-telemetry/opentelemetry-js/issues/1923)\n   */\n  startSpan(type: SpanTypes): Span\n  startSpan(type: SpanTypes, options: TracerSpanOptions): Span\n\n  /**\n   * Returns currently activated span if current context is in the scope of the span.\n   * Returns undefined otherwise.\n   */\n  getActiveScopeSpan(): Span | undefined\n\n  /**\n   * Returns trace propagation data for the currently active context. The format is equal to data provided\n   * through the OpenTelemetry propagator API.\n   */\n  getTracePropagationData(): ClientTraceDataEntry[]\n}\n\ntype NextAttributeNames =\n  | 'next.route'\n  | 'next.page'\n  | 'next.rsc'\n  | 'next.segment'\n  | 'next.span_name'\n  | 'next.span_type'\n  | 'next.clientComponentLoadCount'\ntype OTELAttributeNames = `http.${string}` | `net.${string}`\ntype AttributeNames = NextAttributeNames | OTELAttributeNames\n\n/** we use this map to propagate attributes from nested spans to the top span */\nconst rootSpanAttributesStore = new Map<\n  number,\n  Map<AttributeNames, AttributeValue | undefined>\n>()\nconst rootSpanIdKey = api.createContextKey('next.rootSpanId')\nlet lastSpanId = 0\nconst getSpanId = () => lastSpanId++\n\nexport interface ClientTraceDataEntry {\n  key: string\n  value: string\n}\n\nconst clientTraceDataSetter: TextMapSetter<ClientTraceDataEntry[]> = {\n  set(carrier, key, value) {\n    carrier.push({\n      key,\n      value,\n    })\n  },\n}\n\nclass NextTracerImpl implements NextTracer {\n  /**\n   * Returns an instance to the trace with configured name.\n   * Since wrap / trace can be defined in any place prior to actual trace subscriber initialization,\n   * This should be lazily evaluated.\n   */\n  private getTracerInstance(): Tracer {\n    return trace.getTracer('next.js', '0.0.1')\n  }\n\n  public getContext(): ContextAPI {\n    return context\n  }\n\n  public getTracePropagationData(): ClientTraceDataEntry[] {\n    const activeContext = context.active()\n    const entries: ClientTraceDataEntry[] = []\n    propagation.inject(activeContext, entries, clientTraceDataSetter)\n    return entries\n  }\n\n  public getActiveScopeSpan(): Span | undefined {\n    return trace.getSpan(context?.active())\n  }\n\n  public withPropagatedContext<T, C>(\n    carrier: C,\n    fn: () => T,\n    getter?: TextMapGetter<C>\n  ): T {\n    const activeContext = context.active()\n    if (trace.getSpanContext(activeContext)) {\n      // Active span is already set, too late to propagate.\n      return fn()\n    }\n    const remoteContext = propagation.extract(activeContext, carrier, getter)\n    return context.with(remoteContext, fn)\n  }\n\n  // Trace, wrap implementation is inspired by datadog trace implementation\n  // (https://datadoghq.dev/dd-trace-js/interfaces/tracer.html#trace).\n  public trace<T>(\n    type: SpanTypes,\n    fn: (span?: Span, done?: (error?: Error) => any) => Promise<T>\n  ): Promise<T>\n  public trace<T>(\n    type: SpanTypes,\n    fn: (span?: Span, done?: (error?: Error) => any) => T\n  ): T\n  public trace<T>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: (span?: Span, done?: (error?: Error) => any) => Promise<T>\n  ): Promise<T>\n  public trace<T>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: (span?: Span, done?: (error?: Error) => any) => T\n  ): T\n  public trace<T>(...args: Array<any>) {\n    const [type, fnOrOptions, fnOrEmpty] = args\n\n    // coerce options form overload\n    const {\n      fn,\n      options,\n    }: {\n      fn: (span?: Span, done?: (error?: Error) => any) => T | Promise<T>\n      options: TracerSpanOptions\n    } =\n      typeof fnOrOptions === 'function'\n        ? {\n            fn: fnOrOptions,\n            options: {},\n          }\n        : {\n            fn: fnOrEmpty,\n            options: { ...fnOrOptions },\n          }\n\n    const spanName = options.spanName ?? type\n\n    if (\n      (!NextVanillaSpanAllowlist.includes(type) &&\n        process.env.NEXT_OTEL_VERBOSE !== '1') ||\n      options.hideSpan\n    ) {\n      return fn()\n    }\n\n    // Trying to get active scoped span to assign parent. If option specifies parent span manually, will try to use it.\n    let spanContext = this.getSpanContext(\n      options?.parentSpan ?? this.getActiveScopeSpan()\n    )\n    let isRootSpan = false\n\n    if (!spanContext) {\n      spanContext = context?.active() ?? ROOT_CONTEXT\n      isRootSpan = true\n    } else if (trace.getSpanContext(spanContext)?.isRemote) {\n      isRootSpan = true\n    }\n\n    const spanId = getSpanId()\n\n    options.attributes = {\n      'next.span_name': spanName,\n      'next.span_type': type,\n      ...options.attributes,\n    }\n\n    return context.with(spanContext.setValue(rootSpanIdKey, spanId), () =>\n      this.getTracerInstance().startActiveSpan(\n        spanName,\n        options,\n        (span: Span) => {\n          const startTime =\n            'performance' in globalThis && 'measure' in performance\n              ? globalThis.performance.now()\n              : undefined\n\n          const onCleanup = () => {\n            rootSpanAttributesStore.delete(spanId)\n            if (\n              startTime &&\n              process.env.NEXT_OTEL_PERFORMANCE_PREFIX &&\n              LogSpanAllowList.includes(type || ('' as any))\n            ) {\n              performance.measure(\n                `${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-${(\n                  type.split('.').pop() || ''\n                ).replace(\n                  /[A-Z]/g,\n                  (match: string) => '-' + match.toLowerCase()\n                )}`,\n                {\n                  start: startTime,\n                  end: performance.now(),\n                }\n              )\n            }\n          }\n\n          if (isRootSpan) {\n            rootSpanAttributesStore.set(\n              spanId,\n              new Map(\n                Object.entries(options.attributes ?? {}) as [\n                  AttributeNames,\n                  AttributeValue | undefined,\n                ][]\n              )\n            )\n          }\n          try {\n            if (fn.length > 1) {\n              return fn(span, (err) => closeSpanWithError(span, err))\n            }\n\n            const result = fn(span)\n            if (isThenable(result)) {\n              // If there's error make sure it throws\n              return result\n                .then((res) => {\n                  span.end()\n                  // Need to pass down the promise result,\n                  // it could be react stream response with error { error, stream }\n                  return res\n                })\n                .catch((err) => {\n                  closeSpanWithError(span, err)\n                  throw err\n                })\n                .finally(onCleanup)\n            } else {\n              span.end()\n              onCleanup()\n            }\n\n            return result\n          } catch (err: any) {\n            closeSpanWithError(span, err)\n            onCleanup()\n            throw err\n          }\n        }\n      )\n    )\n  }\n\n  public wrap<T = (...args: Array<any>) => any>(type: SpanTypes, fn: T): T\n  public wrap<T = (...args: Array<any>) => any>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: T\n  ): T\n  public wrap<T = (...args: Array<any>) => any>(\n    type: SpanTypes,\n    options: (...args: any[]) => TracerSpanOptions,\n    fn: T\n  ): T\n  public wrap(...args: Array<any>) {\n    const tracer = this\n    const [name, options, fn] =\n      args.length === 3 ? args : [args[0], {}, args[1]]\n\n    if (\n      !NextVanillaSpanAllowlist.includes(name) &&\n      process.env.NEXT_OTEL_VERBOSE !== '1'\n    ) {\n      return fn\n    }\n\n    return function (this: any) {\n      let optionsObj = options\n      if (typeof optionsObj === 'function' && typeof fn === 'function') {\n        optionsObj = optionsObj.apply(this, arguments)\n      }\n\n      const lastArgId = arguments.length - 1\n      const cb = arguments[lastArgId]\n\n      if (typeof cb === 'function') {\n        const scopeBoundCb = tracer.getContext().bind(context.active(), cb)\n        return tracer.trace(name, optionsObj, (_span, done) => {\n          arguments[lastArgId] = function (err: any) {\n            done?.(err)\n            return scopeBoundCb.apply(this, arguments)\n          }\n\n          return fn.apply(this, arguments)\n        })\n      } else {\n        return tracer.trace(name, optionsObj, () => fn.apply(this, arguments))\n      }\n    }\n  }\n\n  public startSpan(type: SpanTypes): Span\n  public startSpan(type: SpanTypes, options: TracerSpanOptions): Span\n  public startSpan(...args: Array<any>): Span {\n    const [type, options]: [string, TracerSpanOptions | undefined] = args as any\n\n    const spanContext = this.getSpanContext(\n      options?.parentSpan ?? this.getActiveScopeSpan()\n    )\n    return this.getTracerInstance().startSpan(type, options, spanContext)\n  }\n\n  private getSpanContext(parentSpan?: Span) {\n    const spanContext = parentSpan\n      ? trace.setSpan(context.active(), parentSpan)\n      : undefined\n\n    return spanContext\n  }\n\n  public getRootSpanAttributes() {\n    const spanId = context.active().getValue(rootSpanIdKey) as number\n    return rootSpanAttributesStore.get(spanId)\n  }\n\n  public setRootSpanAttribute(key: AttributeNames, value: AttributeValue) {\n    const spanId = context.active().getValue(rootSpanIdKey) as number\n    const attributes = rootSpanAttributesStore.get(spanId)\n    if (attributes) {\n      attributes.set(key, value)\n    }\n  }\n}\n\nconst getTracer = (() => {\n  const tracer = new NextTracerImpl()\n\n  return () => tracer\n})()\n\nexport { getTracer, SpanStatusCode, SpanKind }\nexport type { NextTracer, Span, SpanOptions, ContextAPI, TracerSpanOptions }\n","const DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE'\n\nexport class DynamicServerError extends Error {\n  digest: typeof DYNAMIC_ERROR_CODE = DYNAMIC_ERROR_CODE\n\n  constructor(public readonly description: string) {\n    super(`Dynamic server usage: ${description}`)\n  }\n}\n\nexport function isDynamicServerError(err: unknown): err is DynamicServerError {\n  if (\n    typeof err !== 'object' ||\n    err === null ||\n    !('digest' in err) ||\n    typeof err.digest !== 'string'\n  ) {\n    return false\n  }\n\n  return err.digest === DYNAMIC_ERROR_CODE\n}\n","const NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT'\n\nexport class StaticGenBailoutError extends Error {\n  public readonly code = NEXT_STATIC_GEN_BAILOUT\n}\n\nexport function isStaticGenBailoutError(\n  error: unknown\n): error is StaticGenBailoutError {\n  if (typeof error !== 'object' || error === null || !('code' in error)) {\n    return false\n  }\n\n  return error.code === NEXT_STATIC_GEN_BAILOUT\n}\n","export function isHangingPromiseRejectionError(\n  err: unknown\n): err is HangingPromiseRejectionError {\n  if (typeof err !== 'object' || err === null || !('digest' in err)) {\n    return false\n  }\n\n  return err.digest === HANGING_PROMISE_REJECTION\n}\n\nconst HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION'\n\nclass HangingPromiseRejectionError extends Error {\n  public readonly digest = HANGING_PROMISE_REJECTION\n\n  constructor(\n    public readonly route: string,\n    public readonly expression: string\n  ) {\n    super(\n      `During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \\`setTimeout\\`, \\`after\\`, or similar functions you may observe this error and you should handle it in that context. This occurred at route \"${route}\".`\n    )\n  }\n}\n\ntype AbortListeners = Array<(err: unknown) => void>\nconst abortListenersBySignal = new WeakMap<AbortSignal, AbortListeners>()\n\n/**\n * This function constructs a promise that will never resolve. This is primarily\n * useful for cacheComponents where we use promise resolution timing to determine which\n * parts of a render can be included in a prerender.\n *\n * @internal\n */\nexport function makeHangingPromise<T>(\n  signal: AbortSignal,\n  route: string,\n  expression: string\n): Promise<T> {\n  if (signal.aborted) {\n    return Promise.reject(new HangingPromiseRejectionError(route, expression))\n  } else {\n    const hangingPromise = new Promise<T>((_, reject) => {\n      const boundRejection = reject.bind(\n        null,\n        new HangingPromiseRejectionError(route, expression)\n      )\n      let currentListeners = abortListenersBySignal.get(signal)\n      if (currentListeners) {\n        currentListeners.push(boundRejection)\n      } else {\n        const listeners = [boundRejection]\n        abortListenersBySignal.set(signal, listeners)\n        signal.addEventListener(\n          'abort',\n          () => {\n            for (let i = 0; i < listeners.length; i++) {\n              listeners[i]()\n            }\n          },\n          { once: true }\n        )\n      }\n    })\n    // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so\n    // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct\n    // your own promise out of it you'll need to ensure you handle the error when it rejects.\n    hangingPromise.catch(ignoreReject)\n    return hangingPromise\n  }\n}\n\nfunction ignoreReject() {}\n\nexport function makeDevtoolsIOAwarePromise<T>(underlying: T): Promise<T> {\n  // in React DevTools if we resolve in a setTimeout we will observe\n  // the promise resolution as something that can suspend a boundary or root.\n  return new Promise<T>((resolve) => {\n    // Must use setTimeout to be considered IO React DevTools. setImmediate will not work.\n    setTimeout(() => {\n      resolve(underlying)\n    }, 0)\n  })\n}\n","export const METADATA_BOUNDARY_NAME = '__next_metadata_boundary__'\nexport const VIEWPORT_BOUNDARY_NAME = '__next_viewport_boundary__'\nexport const OUTLET_BOUNDARY_NAME = '__next_outlet_boundary__'\nexport const ROOT_LAYOUT_BOUNDARY_NAME = '__next_root_layout_boundary__'\n","export type ScheduledFn<T = void> = () => T | PromiseLike<T>\nexport type SchedulerFn<T = void> = (cb: ScheduledFn<T>) => void\n\n/**\n * Schedules a function to be called on the next tick after the other promises\n * have been resolved.\n *\n * @param cb the function to schedule\n */\nexport const scheduleOnNextTick = (cb: ScheduledFn<void>) => {\n  // We use Promise.resolve().then() here so that the operation is scheduled at\n  // the end of the promise job queue, we then add it to the next process tick\n  // to ensure it's evaluated afterwards.\n  //\n  // This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255\n  //\n  Promise.resolve().then(() => {\n    if (process.env.NEXT_RUNTIME === 'edge') {\n      setTimeout(cb, 0)\n    } else {\n      process.nextTick(cb)\n    }\n  })\n}\n\n/**\n * Schedules a function to be called using `setImmediate` or `setTimeout` if\n * `setImmediate` is not available (like in the Edge runtime).\n *\n * @param cb the function to schedule\n */\nexport const scheduleImmediate = (cb: ScheduledFn<void>): void => {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    setTimeout(cb, 0)\n  } else {\n    setImmediate(cb)\n  }\n}\n\n/**\n * returns a promise than resolves in a future task. There is no guarantee that the task it resolves in\n * will be the next task but if you await it you can at least be sure that the current task is over and\n * most usefully that the entire microtask queue of the current task has been emptied.\n */\nexport function atLeastOneTask() {\n  return new Promise<void>((resolve) => scheduleImmediate(resolve))\n}\n\n/**\n * This utility function is extracted to make it easier to find places where we are doing\n * specific timing tricks to try to schedule work after React has rendered. This is especially\n * important at the moment because Next.js uses the edge builds of React which use setTimeout to\n * schedule work when you might expect that something like setImmediate would do the trick.\n *\n * Long term we should switch to the node versions of React rendering when possible and then\n * update this to use setImmediate rather than setTimeout\n */\nexport function waitAtLeastOneReactRenderTask(): Promise<void> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    return new Promise((r) => setTimeout(r, 0))\n  } else {\n    return new Promise((r) => setImmediate(r))\n  }\n}\n","// This has to be a shared module which is shared between client component error boundary and dynamic component\nconst BAILOUT_TO_CSR = 'BAILOUT_TO_CLIENT_SIDE_RENDERING'\n\n/** An error that should be thrown when we want to bail out to client-side rendering. */\nexport class BailoutToCSRError extends Error {\n  public readonly digest = BAILOUT_TO_CSR\n\n  constructor(public readonly reason: string) {\n    super(`Bail out to client-side rendering: ${reason}`)\n  }\n}\n\n/** Checks if a passed argument is an error that is thrown if we want to bail out to client-side rendering. */\nexport function isBailoutToCSRError(err: unknown): err is BailoutToCSRError {\n  if (typeof err !== 'object' || err === null || !('digest' in err)) {\n    return false\n  }\n\n  return err.digest === BAILOUT_TO_CSR\n}\n","export class InvariantError extends Error {\n  constructor(message: string, options?: ErrorOptions) {\n    super(\n      `Invariant: ${message.endsWith('.') ? message : message + '.'} This is a bug in Next.js.`,\n      options\n    )\n    this.name = 'InvariantError'\n  }\n}\n","/**\n * The functions provided by this module are used to communicate certain properties\n * about the currently running code so that Next.js can make decisions on how to handle\n * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.\n *\n * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.\n * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts\n * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of\n * Dynamic indications.\n *\n * The first is simply an intention to be dynamic. unstable_noStore is an example of this where\n * the currently executing code simply declares that the current scope is dynamic but if you use it\n * inside unstable_cache it can still be cached. This type of indication can be removed if we ever\n * make the default dynamic to begin with because the only way you would ever be static is inside\n * a cache scope which this indication does not affect.\n *\n * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic\n * because it means that it is inappropriate to cache this at all. using a dynamic data source inside\n * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should\n * read that data outside the cache and pass it in as an argument to the cached function.\n */\n\nimport type { WorkStore } from '../app-render/work-async-storage.external'\nimport type {\n  WorkUnitStore,\n  RequestStore,\n  PrerenderStoreLegacy,\n  PrerenderStoreModern,\n  PrerenderStoreModernRuntime,\n} from '../app-render/work-unit-async-storage.external'\n\n// Once postpone is in stable we should switch to importing the postpone export directly\nimport React from 'react'\n\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport {\n  getRuntimeStagePromise,\n  workUnitAsyncStorage,\n} from './work-unit-async-storage.external'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport {\n  METADATA_BOUNDARY_NAME,\n  VIEWPORT_BOUNDARY_NAME,\n  OUTLET_BOUNDARY_NAME,\n  ROOT_LAYOUT_BOUNDARY_NAME,\n} from '../../lib/framework/boundary-constants'\nimport { scheduleOnNextTick } from '../../lib/scheduler'\nimport { BailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nconst hasPostpone = typeof React.unstable_postpone === 'function'\n\nexport type DynamicAccess = {\n  /**\n   * If debugging, this will contain the stack trace of where the dynamic access\n   * occurred. This is used to provide more information to the user about why\n   * their page is being rendered dynamically.\n   */\n  stack?: string\n\n  /**\n   * The expression that was accessed dynamically.\n   */\n  expression: string\n}\n\n// Stores dynamic reasons used during an RSC render.\nexport type DynamicTrackingState = {\n  /**\n   * When true, stack information will also be tracked during dynamic access.\n   */\n  readonly isDebugDynamicAccesses: boolean | undefined\n\n  /**\n   * The dynamic accesses that occurred during the render.\n   */\n  readonly dynamicAccesses: Array<DynamicAccess>\n\n  syncDynamicErrorWithStack: null | Error\n}\n\n// Stores dynamic reasons used during an SSR render.\nexport type DynamicValidationState = {\n  hasSuspenseAboveBody: boolean\n  hasDynamicMetadata: boolean\n  hasDynamicViewport: boolean\n  hasAllowedDynamic: boolean\n  dynamicErrors: Array<Error>\n}\n\nexport function createDynamicTrackingState(\n  isDebugDynamicAccesses: boolean | undefined\n): DynamicTrackingState {\n  return {\n    isDebugDynamicAccesses,\n    dynamicAccesses: [],\n    syncDynamicErrorWithStack: null,\n  }\n}\n\nexport function createDynamicValidationState(): DynamicValidationState {\n  return {\n    hasSuspenseAboveBody: false,\n    hasDynamicMetadata: false,\n    hasDynamicViewport: false,\n    hasAllowedDynamic: false,\n    dynamicErrors: [],\n  }\n}\n\nexport function getFirstDynamicReason(\n  trackingState: DynamicTrackingState\n): undefined | string {\n  return trackingState.dynamicAccesses[0]?.expression\n}\n\n/**\n * This function communicates that the current scope should be treated as dynamic.\n *\n * In most cases this function is a no-op but if called during\n * a PPR prerender it will postpone the current sub-tree and calling\n * it during a normal prerender will cause the entire prerender to abort\n */\nexport function markCurrentScopeAsDynamic(\n  store: WorkStore,\n  workUnitStore: undefined | Exclude<WorkUnitStore, PrerenderStoreModern>,\n  expression: string\n): void {\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'cache':\n      case 'unstable-cache':\n        // Inside cache scopes, marking a scope as dynamic has no effect,\n        // because the outer cache scope creates a cache boundary. This is\n        // subtly different from reading a dynamic data source, which is\n        // forbidden inside a cache scope.\n        return\n      case 'private-cache':\n        // A private cache scope is already dynamic by definition.\n        return\n      case 'prerender-legacy':\n      case 'prerender-ppr':\n      case 'request':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  // If we're forcing dynamic rendering or we're forcing static rendering, we\n  // don't need to do anything here because the entire page is already dynamic\n  // or it's static and it should not throw or postpone here.\n  if (store.forceDynamic || store.forceStatic) return\n\n  if (store.dynamicShouldError) {\n    throw new StaticGenBailoutError(\n      `Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n    )\n  }\n\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender-ppr':\n        return postponeWithTracking(\n          store.route,\n          expression,\n          workUnitStore.dynamicTracking\n        )\n      case 'prerender-legacy':\n        workUnitStore.revalidate = 0\n\n        // We aren't prerendering, but we are generating a static page. We need\n        // to bail out of static generation.\n        const err = new DynamicServerError(\n          `Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n        )\n        store.dynamicUsageDescription = expression\n        store.dynamicUsageStack = err.stack\n\n        throw err\n      case 'request':\n        if (process.env.NODE_ENV !== 'production') {\n          workUnitStore.usedDynamic = true\n        }\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n}\n\n/**\n * This function is meant to be used when prerendering without cacheComponents or PPR.\n * When called during a build it will cause Next.js to consider the route as dynamic.\n *\n * @internal\n */\nexport function throwToInterruptStaticGeneration(\n  expression: string,\n  store: WorkStore,\n  prerenderStore: PrerenderStoreLegacy\n): never {\n  // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n  const err = new DynamicServerError(\n    `Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n  )\n\n  prerenderStore.revalidate = 0\n\n  store.dynamicUsageDescription = expression\n  store.dynamicUsageStack = err.stack\n\n  throw err\n}\n\n/**\n * This function should be used to track whether something dynamic happened even when\n * we are in a dynamic render. This is useful for Dev where all renders are dynamic but\n * we still track whether dynamic APIs were accessed for helpful messaging\n *\n * @internal\n */\nexport function trackDynamicDataInDynamicRender(workUnitStore: WorkUnitStore) {\n  switch (workUnitStore.type) {\n    case 'cache':\n    case 'unstable-cache':\n      // Inside cache scopes, marking a scope as dynamic has no effect,\n      // because the outer cache scope creates a cache boundary. This is\n      // subtly different from reading a dynamic data source, which is\n      // forbidden inside a cache scope.\n      return\n    case 'private-cache':\n      // A private cache scope is already dynamic by definition.\n      return\n    case 'prerender':\n    case 'prerender-runtime':\n    case 'prerender-legacy':\n    case 'prerender-ppr':\n    case 'prerender-client':\n      break\n    case 'request':\n      if (process.env.NODE_ENV !== 'production') {\n        workUnitStore.usedDynamic = true\n      }\n      break\n    default:\n      workUnitStore satisfies never\n  }\n}\n\nfunction abortOnSynchronousDynamicDataAccess(\n  route: string,\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n): void {\n  const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n\n  const error = createPrerenderInterruptedError(reason)\n\n  prerenderStore.controller.abort(error)\n\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function abortOnSynchronousPlatformIOAccess(\n  route: string,\n  expression: string,\n  errorWithStack: Error,\n  prerenderStore: PrerenderStoreModern\n): void {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n  // It is important that we set this tracking value after aborting. Aborts are executed\n  // synchronously except for the case where you abort during render itself. By setting this\n  // value late we can use it to determine if any of the aborted tasks are the task that\n  // called the sync IO expression in the first place.\n  if (dynamicTracking) {\n    if (dynamicTracking.syncDynamicErrorWithStack === null) {\n      dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n    }\n  }\n}\n\nexport function trackSynchronousPlatformIOAccessInDev(\n  requestStore: RequestStore\n): void {\n  // We don't actually have a controller to abort but we do the semantic equivalent by\n  // advancing the request store out of prerender mode\n  requestStore.prerenderPhase = false\n}\n\n/**\n * use this function when prerendering with cacheComponents. If we are doing a\n * prospective prerender we don't actually abort because we want to discover\n * all caches for the shell. If this is the actual prerender we do abort.\n *\n * This function accepts a prerenderStore but the caller should ensure we're\n * actually running in cacheComponents mode.\n *\n * @internal\n */\nexport function abortAndThrowOnSynchronousRequestDataAccess(\n  route: string,\n  expression: string,\n  errorWithStack: Error,\n  prerenderStore: PrerenderStoreModern\n): never {\n  const prerenderSignal = prerenderStore.controller.signal\n  if (prerenderSignal.aborted === false) {\n    // TODO it would be better to move this aborted check into the callsite so we can avoid making\n    // the error object when it isn't relevant to the aborting of the prerender however\n    // since we need the throw semantics regardless of whether we abort it is easier to land\n    // this way. See how this was handled with `abortOnSynchronousPlatformIOAccess` for a closer\n    // to ideal implementation\n    abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n    // It is important that we set this tracking value after aborting. Aborts are executed\n    // synchronously except for the case where you abort during render itself. By setting this\n    // value late we can use it to determine if any of the aborted tasks are the task that\n    // called the sync IO expression in the first place.\n    const dynamicTracking = prerenderStore.dynamicTracking\n    if (dynamicTracking) {\n      if (dynamicTracking.syncDynamicErrorWithStack === null) {\n        dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n      }\n    }\n  }\n  throw createPrerenderInterruptedError(\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n  )\n}\n\n/**\n * Use this function when dynamically prerendering with dynamicIO.\n * We don't want to error, because it's better to return something\n * (and we've already aborted the render at the point where the sync dynamic error occured),\n * but we should log an error server-side.\n * @internal\n */\nexport function warnOnSyncDynamicError(dynamicTracking: DynamicTrackingState) {\n  if (dynamicTracking.syncDynamicErrorWithStack) {\n    // the server did something sync dynamic, likely\n    // leading to an early termination of the prerender.\n    console.error(dynamicTracking.syncDynamicErrorWithStack)\n  }\n}\n\n// For now these implementations are the same so we just reexport\nexport const trackSynchronousRequestDataAccessInDev =\n  trackSynchronousPlatformIOAccessInDev\n\n/**\n * This component will call `React.postpone` that throws the postponed error.\n */\ntype PostponeProps = {\n  reason: string\n  route: string\n}\nexport function Postpone({ reason, route }: PostponeProps): never {\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  const dynamicTracking =\n    prerenderStore && prerenderStore.type === 'prerender-ppr'\n      ? prerenderStore.dynamicTracking\n      : null\n  postponeWithTracking(route, reason, dynamicTracking)\n}\n\nexport function postponeWithTracking(\n  route: string,\n  expression: string,\n  dynamicTracking: null | DynamicTrackingState\n): never {\n  assertPostpone()\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n\n  React.unstable_postpone(createPostponeReason(route, expression))\n}\n\nfunction createPostponeReason(route: string, expression: string) {\n  return (\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` +\n    `React throws this special object to indicate where. It should not be caught by ` +\n    `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`\n  )\n}\n\nexport function isDynamicPostpone(err: unknown) {\n  if (\n    typeof err === 'object' &&\n    err !== null &&\n    typeof (err as any).message === 'string'\n  ) {\n    return isDynamicPostponeReason((err as any).message)\n  }\n  return false\n}\n\nfunction isDynamicPostponeReason(reason: string) {\n  return (\n    reason.includes(\n      'needs to bail out of prerendering at this point because it used'\n    ) &&\n    reason.includes(\n      'Learn more: https://nextjs.org/docs/messages/ppr-caught-error'\n    )\n  )\n}\n\nif (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {\n  throw new Error(\n    'Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'\n  )\n}\n\nconst NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED'\n\nfunction createPrerenderInterruptedError(message: string): Error {\n  const error = new Error(message)\n  ;(error as any).digest = NEXT_PRERENDER_INTERRUPTED\n  return error\n}\n\ntype DigestError = Error & {\n  digest: string\n}\n\nexport function isPrerenderInterruptedError(\n  error: unknown\n): error is DigestError {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    (error as any).digest === NEXT_PRERENDER_INTERRUPTED &&\n    'name' in error &&\n    'message' in error &&\n    error instanceof Error\n  )\n}\n\nexport function accessedDynamicData(\n  dynamicAccesses: Array<DynamicAccess>\n): boolean {\n  return dynamicAccesses.length > 0\n}\n\nexport function consumeDynamicAccess(\n  serverDynamic: DynamicTrackingState,\n  clientDynamic: DynamicTrackingState\n): DynamicTrackingState['dynamicAccesses'] {\n  // We mutate because we only call this once we are no longer writing\n  // to the dynamicTrackingState and it's more efficient than creating a new\n  // array.\n  serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses)\n  return serverDynamic.dynamicAccesses\n}\n\nexport function formatDynamicAPIAccesses(\n  dynamicAccesses: Array<DynamicAccess>\n): string[] {\n  return dynamicAccesses\n    .filter(\n      (access): access is Required<DynamicAccess> =>\n        typeof access.stack === 'string' && access.stack.length > 0\n    )\n    .map(({ expression, stack }) => {\n      stack = stack\n        .split('\\n')\n        // Remove the \"Error: \" prefix from the first line of the stack trace as\n        // well as the first 4 lines of the stack trace which is the distance\n        // from the user code and the `new Error().stack` call.\n        .slice(4)\n        .filter((line) => {\n          // Exclude Next.js internals from the stack trace.\n          if (line.includes('node_modules/next/')) {\n            return false\n          }\n\n          // Exclude anonymous functions from the stack trace.\n          if (line.includes(' (<anonymous>)')) {\n            return false\n          }\n\n          // Exclude Node.js internals from the stack trace.\n          if (line.includes(' (node:')) {\n            return false\n          }\n\n          return true\n        })\n        .join('\\n')\n      return `Dynamic API Usage Debug - ${expression}:\\n${stack}`\n    })\n}\n\nfunction assertPostpone() {\n  if (!hasPostpone) {\n    throw new Error(\n      `Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`\n    )\n  }\n}\n\n/**\n * This is a bit of a hack to allow us to abort a render using a Postpone instance instead of an Error which changes React's\n * abort semantics slightly.\n */\nexport function createRenderInBrowserAbortSignal(): AbortSignal {\n  const controller = new AbortController()\n  controller.abort(new BailoutToCSRError('Render in Browser'))\n  return controller.signal\n}\n\n/**\n * In a prerender, we may end up with hanging Promises as inputs due them\n * stalling on connection() or because they're loading dynamic data. In that\n * case we need to abort the encoding of arguments since they'll never complete.\n */\nexport function createHangingInputAbortSignal(\n  workUnitStore: WorkUnitStore\n): AbortSignal | undefined {\n  switch (workUnitStore.type) {\n    case 'prerender':\n    case 'prerender-runtime':\n      const controller = new AbortController()\n\n      if (workUnitStore.cacheSignal) {\n        // If we have a cacheSignal it means we're in a prospective render. If\n        // the input we're waiting on is coming from another cache, we do want\n        // to wait for it so that we can resolve this cache entry too.\n        workUnitStore.cacheSignal.inputReady().then(() => {\n          controller.abort()\n        })\n      } else {\n        // Otherwise we're in the final render and we should already have all\n        // our caches filled.\n        // If the prerender uses stages, we have wait until the runtime stage,\n        // at which point all runtime inputs will be resolved.\n        // (otherwise, a runtime prerender might consider `cookies()` hanging\n        //  even though they'd resolve in the next task.)\n        //\n        // We might still be waiting on some microtasks so we\n        // wait one tick before giving up. When we give up, we still want to\n        // render the content of this cache as deeply as we can so that we can\n        // suspend as deeply as possible in the tree or not at all if we don't\n        // end up waiting for the input.\n        const runtimeStagePromise = getRuntimeStagePromise(workUnitStore)\n        if (runtimeStagePromise) {\n          runtimeStagePromise.then(() =>\n            scheduleOnNextTick(() => controller.abort())\n          )\n        } else {\n          scheduleOnNextTick(() => controller.abort())\n        }\n      }\n\n      return controller.signal\n    case 'prerender-client':\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n    case 'request':\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n      return undefined\n    default:\n      workUnitStore satisfies never\n  }\n}\n\nexport function annotateDynamicAccess(\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n) {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function useDynamicRouteParams(expression: string) {\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workStore && workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender-client':\n      case 'prerender': {\n        const fallbackParams = workUnitStore.fallbackRouteParams\n        if (fallbackParams && fallbackParams.size > 0) {\n          // We are in a prerender with cacheComponents semantics. We are going to\n          // hang here and never resolve. This will cause the currently\n          // rendering component to effectively be a dynamic hole.\n          React.use(\n            makeHangingPromise(\n              workUnitStore.renderSignal,\n              workStore.route,\n              expression\n            )\n          )\n        }\n        break\n      }\n      case 'prerender-ppr': {\n        const fallbackParams = workUnitStore.fallbackRouteParams\n        if (fallbackParams && fallbackParams.size > 0) {\n          return postponeWithTracking(\n            workStore.route,\n            expression,\n            workUnitStore.dynamicTracking\n          )\n        }\n        break\n      }\n      case 'prerender-runtime':\n        throw new InvariantError(\n          `\\`${expression}\\` was called during a runtime prerender. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n        )\n      case 'cache':\n      case 'private-cache':\n        throw new InvariantError(\n          `\\`${expression}\\` was called inside a cache scope. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n        )\n      case 'prerender-legacy':\n      case 'request':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n}\n\nconst hasSuspenseRegex = /\\n\\s+at Suspense \\(<anonymous>\\)/\n\n// Common implicit body tags that React will treat as body when placed directly in html\nconst bodyAndImplicitTags =\n  'body|div|main|section|article|aside|header|footer|nav|form|p|span|h1|h2|h3|h4|h5|h6'\n\n// Detects when RootLayoutBoundary (our framework marker component) appears\n// after Suspense in the component stack, indicating the root layout is wrapped\n// within a Suspense boundary. Ensures no body/html/implicit-body components are in between.\n//\n// Example matches:\n//   at Suspense (<anonymous>)\n//   at __next_root_layout_boundary__ (<anonymous>)\n//\n// Or with other components in between (but not body/html/implicit-body):\n//   at Suspense (<anonymous>)\n//   at SomeComponent (<anonymous>)\n//   at __next_root_layout_boundary__ (<anonymous>)\nconst hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex = new RegExp(\n  `\\\\n\\\\s+at Suspense \\\\(<anonymous>\\\\)(?:(?!\\\\n\\\\s+at (?:${bodyAndImplicitTags}) \\\\(<anonymous>\\\\))[\\\\s\\\\S])*?\\\\n\\\\s+at ${ROOT_LAYOUT_BOUNDARY_NAME} \\\\([^\\\\n]*\\\\)`\n)\n\nconst hasMetadataRegex = new RegExp(\n  `\\\\n\\\\s+at ${METADATA_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasViewportRegex = new RegExp(\n  `\\\\n\\\\s+at ${VIEWPORT_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasOutletRegex = new RegExp(`\\\\n\\\\s+at ${OUTLET_BOUNDARY_NAME}[\\\\n\\\\s]`)\n\nexport function trackAllowedDynamicAccess(\n  workStore: WorkStore,\n  componentStack: string,\n  dynamicValidation: DynamicValidationState,\n  clientDynamic: DynamicTrackingState\n) {\n  if (hasOutletRegex.test(componentStack)) {\n    // We don't need to track that this is dynamic. It is only so when something else is also dynamic.\n    return\n  } else if (hasMetadataRegex.test(componentStack)) {\n    dynamicValidation.hasDynamicMetadata = true\n    return\n  } else if (hasViewportRegex.test(componentStack)) {\n    dynamicValidation.hasDynamicViewport = true\n    return\n  } else if (\n    hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex.test(\n      componentStack\n    )\n  ) {\n    // For Suspense within body, the prelude wouldn't be empty so it wouldn't violate the empty static shells rule.\n    // But if you have Suspense above body, the prelude is empty but we allow that because having Suspense\n    // is an explicit signal from the user that they acknowledge the empty shell and want dynamic rendering.\n    dynamicValidation.hasAllowedDynamic = true\n    dynamicValidation.hasSuspenseAboveBody = true\n    return\n  } else if (hasSuspenseRegex.test(componentStack)) {\n    // this error had a Suspense boundary above it so we don't need to report it as a source\n    // of disallowed\n    dynamicValidation.hasAllowedDynamic = true\n    return\n  } else if (clientDynamic.syncDynamicErrorWithStack) {\n    // This task was the task that called the sync error.\n    dynamicValidation.dynamicErrors.push(\n      clientDynamic.syncDynamicErrorWithStack\n    )\n    return\n  } else {\n    const message = `Route \"${workStore.route}\": A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a \"use cache\" above it. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense`\n    const error = createErrorWithComponentOrOwnerStack(message, componentStack)\n    dynamicValidation.dynamicErrors.push(error)\n    return\n  }\n}\n\n/**\n * In dev mode, we prefer using the owner stack, otherwise the provided\n * component stack is used.\n */\nfunction createErrorWithComponentOrOwnerStack(\n  message: string,\n  componentStack: string\n) {\n  const ownerStack =\n    process.env.NODE_ENV !== 'production' && React.captureOwnerStack\n      ? React.captureOwnerStack()\n      : null\n\n  const error = new Error(message)\n  error.stack = error.name + ': ' + message + (ownerStack ?? componentStack)\n  return error\n}\n\nexport enum PreludeState {\n  Full = 0,\n  Empty = 1,\n  Errored = 2,\n}\n\nexport function logDisallowedDynamicError(\n  workStore: WorkStore,\n  error: Error\n): void {\n  console.error(error)\n\n  if (!workStore.dev) {\n    if (workStore.hasReadableErrorStacks) {\n      console.error(\n        `To get a more detailed stack trace and pinpoint the issue, start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.`\n      )\n    } else {\n      console.error(`To get a more detailed stack trace and pinpoint the issue, try one of the following:\n  - Start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.\n  - Rerun the production build with \\`next build --debug-prerender\\` to generate better stack traces.`)\n    }\n  }\n}\n\nexport function throwIfDisallowedDynamic(\n  workStore: WorkStore,\n  prelude: PreludeState,\n  dynamicValidation: DynamicValidationState,\n  serverDynamic: DynamicTrackingState\n): void {\n  if (prelude !== PreludeState.Full) {\n    if (dynamicValidation.hasSuspenseAboveBody) {\n      // This route has opted into allowing fully dynamic rendering\n      // by including a Suspense boundary above the body. In this case\n      // a lack of a shell is not considered disallowed so we simply return\n      return\n    }\n\n    if (serverDynamic.syncDynamicErrorWithStack) {\n      // There is no shell and the server did something sync dynamic likely\n      // leading to an early termination of the prerender before the shell\n      // could be completed. We terminate the build/validating render.\n      logDisallowedDynamicError(\n        workStore,\n        serverDynamic.syncDynamicErrorWithStack\n      )\n      throw new StaticGenBailoutError()\n    }\n\n    // We didn't have any sync bailouts but there may be user code which\n    // blocked the root. We would have captured these during the prerender\n    // and can log them here and then terminate the build/validating render\n    const dynamicErrors = dynamicValidation.dynamicErrors\n    if (dynamicErrors.length > 0) {\n      for (let i = 0; i < dynamicErrors.length; i++) {\n        logDisallowedDynamicError(workStore, dynamicErrors[i])\n      }\n\n      throw new StaticGenBailoutError()\n    }\n\n    // If we got this far then the only other thing that could be blocking\n    // the root is dynamic Viewport. If this is dynamic then\n    // you need to opt into that by adding a Suspense boundary above the body\n    // to indicate your are ok with fully dynamic rendering.\n    if (dynamicValidation.hasDynamicViewport) {\n      console.error(\n        `Route \"${workStore.route}\" has a \\`generateViewport\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`\n      )\n      throw new StaticGenBailoutError()\n    }\n\n    if (prelude === PreludeState.Empty) {\n      // If we ever get this far then we messed up the tracking of invalid dynamic.\n      // We still adhere to the constraint that you must produce a shell but invite the\n      // user to report this as a bug in Next.js.\n      console.error(\n        `Route \"${workStore.route}\" did not produce a static shell and Next.js was unable to determine a reason. This is a bug in Next.js.`\n      )\n      throw new StaticGenBailoutError()\n    }\n  } else {\n    if (\n      dynamicValidation.hasAllowedDynamic === false &&\n      dynamicValidation.hasDynamicMetadata\n    ) {\n      console.error(\n        `Route \"${workStore.route}\" has a \\`generateMetadata\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`\n      )\n      throw new StaticGenBailoutError()\n    }\n  }\n}\n\nexport function delayUntilRuntimeStage<T>(\n  prerenderStore: PrerenderStoreModernRuntime,\n  result: Promise<T>\n): Promise<T> {\n  if (prerenderStore.runtimeStagePromise) {\n    return prerenderStore.runtimeStagePromise.then(() => result)\n  }\n  return result\n}\n","/**\n * A `Promise.withResolvers` implementation that exposes the `resolve` and\n * `reject` functions on a `Promise`.\n *\n * @see https://tc39.es/proposal-promise-with-resolvers/\n */\nexport class DetachedPromise<T = any> {\n  public readonly resolve: (value: T | PromiseLike<T>) => void\n  public readonly reject: (reason: any) => void\n  public readonly promise: Promise<T>\n\n  constructor() {\n    let resolve: (value: T | PromiseLike<T>) => void\n    let reject: (reason: any) => void\n\n    // Create the promise and assign the resolvers to the object.\n    this.promise = new Promise<T>((res, rej) => {\n      resolve = res\n      reject = rej\n    })\n\n    // We know that resolvers is defined because the Promise constructor runs\n    // synchronously.\n    this.resolve = resolve!\n    this.reject = reject!\n  }\n}\n","export const ENCODED_TAGS = {\n  // opening tags do not have the closing `>` since they can contain other attributes such as `<body className=''>`\n  OPENING: {\n    // <html\n    HTML: new Uint8Array([60, 104, 116, 109, 108]),\n    // <body\n    BODY: new Uint8Array([60, 98, 111, 100, 121]),\n  },\n  CLOSED: {\n    // </head>\n    HEAD: new Uint8Array([60, 47, 104, 101, 97, 100, 62]),\n    // </body>\n    BODY: new Uint8Array([60, 47, 98, 111, 100, 121, 62]),\n    // </html>\n    HTML: new Uint8Array([60, 47, 104, 116, 109, 108, 62]),\n    // </body></html>\n    BODY_AND_HTML: new Uint8Array([\n      60, 47, 98, 111, 100, 121, 62, 60, 47, 104, 116, 109, 108, 62,\n    ]),\n  },\n  META: {\n    // Only the match the prefix cause the suffix can be different wether it's xml compatible or not \">\" or \"/>\"\n    // <meta name=\"nxt-icon\"\n    // This is a special mark that will be replaced by the icon insertion script tag.\n    ICON_MARK: new Uint8Array([\n      60, 109, 101, 116, 97, 32, 110, 97, 109, 101, 61, 34, 194, 171, 110, 120,\n      116, 45, 105, 99, 111, 110, 194, 187, 34,\n    ]),\n  },\n} as const\n","/**\n * Find the starting index of Uint8Array `b` within Uint8Array `a`.\n */\nexport function indexOfUint8Array(a: Uint8Array, b: Uint8Array) {\n  if (b.length === 0) return 0\n  if (a.length === 0 || b.length > a.length) return -1\n\n  // start iterating through `a`\n  for (let i = 0; i <= a.length - b.length; i++) {\n    let completeMatch = true\n    // from index `i`, iterate through `b` and check for mismatch\n    for (let j = 0; j < b.length; j++) {\n      // if the values do not match, then this isn't a complete match, exit `b` iteration early and iterate to next index of `a`.\n      if (a[i + j] !== b[j]) {\n        completeMatch = false\n        break\n      }\n    }\n\n    if (completeMatch) {\n      return i\n    }\n  }\n\n  return -1\n}\n\n/**\n * Check if two Uint8Arrays are strictly equivalent.\n */\nexport function isEquivalentUint8Arrays(a: Uint8Array, b: Uint8Array) {\n  if (a.length !== b.length) return false\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false\n  }\n\n  return true\n}\n\n/**\n * Remove Uint8Array `b` from Uint8Array `a`.\n *\n * If `b` is not in `a`, `a` is returned unchanged.\n *\n * Otherwise, the function returns a new Uint8Array instance with size `a.length - b.length`\n */\nexport function removeFromUint8Array(a: Uint8Array, b: Uint8Array) {\n  const tagIndex = indexOfUint8Array(a, b)\n  if (tagIndex === 0) return a.subarray(b.length)\n  if (tagIndex > -1) {\n    const removed = new Uint8Array(a.length - b.length)\n    removed.set(a.slice(0, tagIndex))\n    removed.set(a.slice(tagIndex + b.length), tagIndex)\n    return removed\n  } else {\n    return a\n  }\n}\n","export const MISSING_ROOT_TAGS_ERROR = 'NEXT_MISSING_ROOT_TAGS'\n","// In output: export mode, the build id is added to the start of the HTML\n// document, directly after the doctype declaration. During a prefetch, the\n// client performs a range request to get the build id, so it can check whether\n// the target page belongs to the same build.\n//\n// The first 64 bytes of the document are requested. The exact number isn't\n// too important; it must be larger than the build id + doctype + closing and\n// ending comment markers, but it doesn't need to match the end of the\n// comment exactly.\n//\n// Build ids are 21 bytes long in the default implementation, though this\n// can be overridden in the Next.js config. For the purposes of this check,\n// it's OK to only match the start of the id, so we'll truncate it if exceeds\n// a certain length.\n\nconst DOCTYPE_PREFIX = '<!DOCTYPE html>' // 15 bytes\nconst MAX_BUILD_ID_LENGTH = 24\n\n// Request the first 64 bytes. The Range header is inclusive of the end value.\nexport const DOC_PREFETCH_RANGE_HEADER_VALUE = 'bytes=0-63'\n\nfunction escapeBuildId(buildId: string) {\n  // If the build id is longer than the given limit, it's OK for our purposes\n  // to only match the beginning.\n  const truncated = buildId.slice(0, MAX_BUILD_ID_LENGTH)\n  // Replace hyphens with underscores so it doesn't break the HTML comment.\n  // (Unlikely, but if this did happen it would break the whole document.)\n  return truncated.replace(/-/g, '_')\n}\n\nexport function insertBuildIdComment(originalHtml: string, buildId: string) {\n  if (\n    // Skip if the build id contains a closing comment marker.\n    buildId.includes('-->') ||\n    // React always inserts a doctype at the start of the document. Skip if it\n    // isn't present. Shouldn't happen; suggests an issue elsewhere.\n    !originalHtml.startsWith(DOCTYPE_PREFIX)\n  ) {\n    // Return the original HTML unchanged. This means the document will not\n    // be prefetched.\n    // TODO: The build id comment is currently only used during prefetches, but\n    // if we eventually use this mechanism for regular navigations, we may need\n    // to error during build if we fail to insert it for some reason.\n    return originalHtml\n  }\n  // The comment must be inserted after the doctype.\n  return originalHtml.replace(\n    DOCTYPE_PREFIX,\n    DOCTYPE_PREFIX + '<!--' + escapeBuildId(buildId) + '-->'\n  )\n}\n\nexport function doesExportedHtmlMatchBuildId(\n  partialHtmlDocument: string,\n  buildId: string\n) {\n  // Check whether the document starts with the expected buildId.\n  return partialHtmlDocument.startsWith(\n    DOCTYPE_PREFIX + '<!--' + escapeBuildId(buildId) + '-->'\n  )\n}\n","import type { ReactDOMServerReadableStream } from 'react-dom/server'\nimport { getTracer } from '../lib/trace/tracer'\nimport { AppRenderSpan } from '../lib/trace/constants'\nimport { DetachedPromise } from '../../lib/detached-promise'\nimport { scheduleImmediate, atLeastOneTask } from '../../lib/scheduler'\nimport { ENCODED_TAGS } from './encoded-tags'\nimport {\n  indexOfUint8Array,\n  isEquivalentUint8Arrays,\n  removeFromUint8Array,\n} from './uint8array-helpers'\nimport { MISSING_ROOT_TAGS_ERROR } from '../../shared/lib/errors/constants'\nimport { insertBuildIdComment } from '../../shared/lib/segment-cache/output-export-prefetch-encoding'\n\nfunction voidCatch() {\n  // this catcher is designed to be used with pipeTo where we expect the underlying\n  // pipe implementation to forward errors but we don't want the pipeTo promise to reject\n  // and be unhandled\n}\n\n// We can share the same encoder instance everywhere\n// Notably we cannot do the same for TextDecoder because it is stateful\n// when handling streaming data\nconst encoder = new TextEncoder()\n\nexport function chainStreams<T>(\n  ...streams: ReadableStream<T>[]\n): ReadableStream<T> {\n  // If we have no streams, return an empty stream. This behavior is\n  // intentional as we're now providing the `RenderResult.EMPTY` value.\n  if (streams.length === 0) {\n    return new ReadableStream<T>({\n      start(controller) {\n        controller.close()\n      },\n    })\n  }\n\n  // If we only have 1 stream we fast path it by returning just this stream\n  if (streams.length === 1) {\n    return streams[0]\n  }\n\n  const { readable, writable } = new TransformStream()\n\n  // We always initiate pipeTo immediately. We know we have at least 2 streams\n  // so we need to avoid closing the writable when this one finishes.\n  let promise = streams[0].pipeTo(writable, { preventClose: true })\n\n  let i = 1\n  for (; i < streams.length - 1; i++) {\n    const nextStream = streams[i]\n    promise = promise.then(() =>\n      nextStream.pipeTo(writable, { preventClose: true })\n    )\n  }\n\n  // We can omit the length check because we halted before the last stream and there\n  // is at least two streams so the lastStream here will always be defined\n  const lastStream = streams[i]\n  promise = promise.then(() => lastStream.pipeTo(writable))\n\n  // Catch any errors from the streams and ignore them, they will be handled\n  // by whatever is consuming the readable stream.\n  promise.catch(voidCatch)\n\n  return readable\n}\n\nexport function streamFromString(str: string): ReadableStream<Uint8Array> {\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(encoder.encode(str))\n      controller.close()\n    },\n  })\n}\n\nexport function streamFromBuffer(chunk: Buffer): ReadableStream<Uint8Array> {\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(chunk)\n      controller.close()\n    },\n  })\n}\n\nexport async function streamToBuffer(\n  stream: ReadableStream<Uint8Array>\n): Promise<Buffer> {\n  const reader = stream.getReader()\n  const chunks: Uint8Array[] = []\n\n  while (true) {\n    const { done, value } = await reader.read()\n    if (done) {\n      break\n    }\n\n    chunks.push(value)\n  }\n\n  return Buffer.concat(chunks)\n}\n\nexport async function streamToString(\n  stream: ReadableStream<Uint8Array>,\n  signal?: AbortSignal\n): Promise<string> {\n  const decoder = new TextDecoder('utf-8', { fatal: true })\n  let string = ''\n\n  for await (const chunk of stream) {\n    if (signal?.aborted) {\n      return string\n    }\n\n    string += decoder.decode(chunk, { stream: true })\n  }\n\n  string += decoder.decode()\n\n  return string\n}\n\nexport function createBufferedTransformStream(): TransformStream<\n  Uint8Array,\n  Uint8Array\n> {\n  let bufferedChunks: Array<Uint8Array> = []\n  let bufferByteLength: number = 0\n  let pending: DetachedPromise<void> | undefined\n\n  const flush = (controller: TransformStreamDefaultController) => {\n    // If we already have a pending flush, then return early.\n    if (pending) return\n\n    const detached = new DetachedPromise<void>()\n    pending = detached\n\n    scheduleImmediate(() => {\n      try {\n        const chunk = new Uint8Array(bufferByteLength)\n        let copiedBytes = 0\n\n        for (let i = 0; i < bufferedChunks.length; i++) {\n          const bufferedChunk = bufferedChunks[i]\n          chunk.set(bufferedChunk, copiedBytes)\n          copiedBytes += bufferedChunk.byteLength\n        }\n        // We just wrote all the buffered chunks so we need to reset the bufferedChunks array\n        // and our bufferByteLength to prepare for the next round of buffered chunks\n        bufferedChunks.length = 0\n        bufferByteLength = 0\n        controller.enqueue(chunk)\n      } catch {\n        // If an error occurs while enqueuing it can't be due to this\n        // transformers fault. It's likely due to the controller being\n        // errored due to the stream being cancelled.\n      } finally {\n        pending = undefined\n        detached.resolve()\n      }\n    })\n  }\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      // Combine the previous buffer with the new chunk.\n      bufferedChunks.push(chunk)\n      bufferByteLength += chunk.byteLength\n\n      // Flush the buffer to the controller.\n      flush(controller)\n    },\n    flush() {\n      if (!pending) return\n\n      return pending.promise\n    },\n  })\n}\n\nfunction createPrefetchCommentStream(\n  isBuildTimePrerendering: boolean,\n  buildId: string\n): TransformStream<Uint8Array, Uint8Array> {\n  // Insert an extra comment at the beginning of the HTML document. This must\n  // come after the DOCTYPE, which is inserted by React.\n  //\n  // The first chunk sent by React will contain the doctype. After that, we can\n  // pass through the rest of the chunks as-is.\n  let didTransformFirstChunk = false\n  return new TransformStream({\n    transform(chunk, controller) {\n      if (isBuildTimePrerendering && !didTransformFirstChunk) {\n        didTransformFirstChunk = true\n        const decoder = new TextDecoder('utf-8', { fatal: true })\n        const chunkStr = decoder.decode(chunk, {\n          stream: true,\n        })\n        const updatedChunkStr = insertBuildIdComment(chunkStr, buildId)\n        controller.enqueue(encoder.encode(updatedChunkStr))\n        return\n      }\n      controller.enqueue(chunk)\n    },\n  })\n}\n\nexport function renderToInitialFizzStream({\n  ReactDOMServer,\n  element,\n  streamOptions,\n}: {\n  ReactDOMServer: {\n    renderToReadableStream: typeof import('react-dom/server').renderToReadableStream\n  }\n  element: React.ReactElement\n  streamOptions?: Parameters<typeof ReactDOMServer.renderToReadableStream>[1]\n}): Promise<ReactDOMServerReadableStream> {\n  return getTracer().trace(AppRenderSpan.renderToReadableStream, async () =>\n    ReactDOMServer.renderToReadableStream(element, streamOptions)\n  )\n}\n\nfunction createMetadataTransformStream(\n  insert: () => Promise<string> | string\n): TransformStream<Uint8Array, Uint8Array> {\n  let chunkIndex = -1\n  let isMarkRemoved = false\n\n  return new TransformStream({\n    async transform(chunk, controller) {\n      let iconMarkIndex = -1\n      let closedHeadIndex = -1\n      chunkIndex++\n\n      if (isMarkRemoved) {\n        controller.enqueue(chunk)\n        return\n      }\n      let iconMarkLength = 0\n      // Only search for the closed head tag once\n      if (iconMarkIndex === -1) {\n        iconMarkIndex = indexOfUint8Array(chunk, ENCODED_TAGS.META.ICON_MARK)\n        if (iconMarkIndex === -1) {\n          controller.enqueue(chunk)\n          return\n        } else {\n          // When we found the `<meta name=\"nxt-icon\"` tag prefix, we will remove it from the chunk.\n          // Its close tag could either be `/>` or `>`, checking the next char to ensure we cover both cases.\n          iconMarkLength = ENCODED_TAGS.META.ICON_MARK.length\n          // Check if next char is /, this is for xml mode.\n          if (chunk[iconMarkIndex + iconMarkLength] === 47) {\n            iconMarkLength += 2\n          } else {\n            // The last char is `>`\n            iconMarkLength++\n          }\n        }\n      }\n\n      // Check if icon mark is inside <head> tag in the first chunk.\n      if (chunkIndex === 0) {\n        closedHeadIndex = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.HEAD)\n        if (iconMarkIndex !== -1) {\n          // The mark icon is located in the 1st chunk before the head tag.\n          // We do not need to insert the script tag in this case because it's in the head.\n          // Just remove the icon mark from the chunk.\n          if (iconMarkIndex < closedHeadIndex) {\n            const replaced = new Uint8Array(chunk.length - iconMarkLength)\n\n            // Remove the icon mark from the chunk.\n            replaced.set(chunk.subarray(0, iconMarkIndex))\n            replaced.set(\n              chunk.subarray(iconMarkIndex + iconMarkLength),\n              iconMarkIndex\n            )\n            chunk = replaced\n          } else {\n            // The icon mark is after the head tag, replace and insert the script tag at that position.\n            const insertion = await insert()\n            const encodedInsertion = encoder.encode(insertion)\n            const insertionLength = encodedInsertion.length\n            const replaced = new Uint8Array(\n              chunk.length - iconMarkLength + insertionLength\n            )\n            replaced.set(chunk.subarray(0, iconMarkIndex))\n            replaced.set(encodedInsertion, iconMarkIndex)\n            replaced.set(\n              chunk.subarray(iconMarkIndex + iconMarkLength),\n              iconMarkIndex + insertionLength\n            )\n            chunk = replaced\n          }\n          isMarkRemoved = true\n        }\n        // If there's no icon mark located, it will be handled later when if present in the following chunks.\n      } else {\n        // When it's appeared in the following chunks, we'll need to\n        // remove the mark and then insert the script tag at that position.\n        const insertion = await insert()\n        const encodedInsertion = encoder.encode(insertion)\n        const insertionLength = encodedInsertion.length\n        // Replace the icon mark with the hoist script or empty string.\n        const replaced = new Uint8Array(\n          chunk.length - iconMarkLength + insertionLength\n        )\n        // Set the first part of the chunk, before the icon mark.\n        replaced.set(chunk.subarray(0, iconMarkIndex))\n        // Set the insertion after the icon mark.\n        replaced.set(encodedInsertion, iconMarkIndex)\n\n        // Set the rest of the chunk after the icon mark.\n        replaced.set(\n          chunk.subarray(iconMarkIndex + iconMarkLength),\n          iconMarkIndex + insertionLength\n        )\n        chunk = replaced\n        isMarkRemoved = true\n      }\n      controller.enqueue(chunk)\n    },\n  })\n}\n\nfunction createHeadInsertionTransformStream(\n  insert: () => Promise<string>\n): TransformStream<Uint8Array, Uint8Array> {\n  let inserted = false\n\n  // We need to track if this transform saw any bytes because if it didn't\n  // we won't want to insert any server HTML at all\n  let hasBytes = false\n\n  return new TransformStream({\n    async transform(chunk, controller) {\n      hasBytes = true\n\n      const insertion = await insert()\n      if (inserted) {\n        if (insertion) {\n          const encodedInsertion = encoder.encode(insertion)\n          controller.enqueue(encodedInsertion)\n        }\n        controller.enqueue(chunk)\n      } else {\n        // TODO (@Ethan-Arrowood): Replace the generic `indexOfUint8Array` method with something finely tuned for the subset of things actually being checked for.\n        const index = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.HEAD)\n        // In fully static rendering or non PPR rendering cases:\n        // `/head>` will always be found in the chunk in first chunk rendering.\n        if (index !== -1) {\n          if (insertion) {\n            const encodedInsertion = encoder.encode(insertion)\n            // Get the total count of the bytes in the chunk and the insertion\n            // e.g.\n            // chunk = <head><meta charset=\"utf-8\"></head>\n            // insertion = <script>...</script>\n            // output = <head><meta charset=\"utf-8\"> [ <script>...</script> ] </head>\n            const insertedHeadContent = new Uint8Array(\n              chunk.length + encodedInsertion.length\n            )\n            // Append the first part of the chunk, before the head tag\n            insertedHeadContent.set(chunk.slice(0, index))\n            // Append the server inserted content\n            insertedHeadContent.set(encodedInsertion, index)\n            // Append the rest of the chunk\n            insertedHeadContent.set(\n              chunk.slice(index),\n              index + encodedInsertion.length\n            )\n            controller.enqueue(insertedHeadContent)\n          } else {\n            controller.enqueue(chunk)\n          }\n          inserted = true\n        } else {\n          // This will happens in PPR rendering during next start, when the page is partially rendered.\n          // When the page resumes, the head tag will be found in the middle of the chunk.\n          // Where we just need to append the insertion and chunk to the current stream.\n          // e.g.\n          // PPR-static: <head>...</head><body> [ resume content ] </body>\n          // PPR-resume: [ insertion ] [ rest content ]\n          if (insertion) {\n            controller.enqueue(encoder.encode(insertion))\n          }\n          controller.enqueue(chunk)\n          inserted = true\n        }\n      }\n    },\n    async flush(controller) {\n      // Check before closing if there's anything remaining to insert.\n      if (hasBytes) {\n        const insertion = await insert()\n        if (insertion) {\n          controller.enqueue(encoder.encode(insertion))\n        }\n      }\n    },\n  })\n}\n\n// Suffix after main body content - scripts before </body>,\n// but wait for the major chunks to be enqueued.\nfunction createDeferredSuffixStream(\n  suffix: string\n): TransformStream<Uint8Array, Uint8Array> {\n  let flushed = false\n  let pending: DetachedPromise<void> | undefined\n\n  const flush = (controller: TransformStreamDefaultController) => {\n    const detached = new DetachedPromise<void>()\n    pending = detached\n\n    scheduleImmediate(() => {\n      try {\n        controller.enqueue(encoder.encode(suffix))\n      } catch {\n        // If an error occurs while enqueuing it can't be due to this\n        // transformers fault. It's likely due to the controller being\n        // errored due to the stream being cancelled.\n      } finally {\n        pending = undefined\n        detached.resolve()\n      }\n    })\n  }\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      controller.enqueue(chunk)\n\n      // If we've already flushed, we're done.\n      if (flushed) return\n\n      // Schedule the flush to happen.\n      flushed = true\n      flush(controller)\n    },\n    flush(controller) {\n      if (pending) return pending.promise\n      if (flushed) return\n\n      // Flush now.\n      controller.enqueue(encoder.encode(suffix))\n    },\n  })\n}\n\nfunction createFlightDataInjectionTransformStream(\n  stream: ReadableStream<Uint8Array>,\n  delayDataUntilFirstHtmlChunk: boolean\n): TransformStream<Uint8Array, Uint8Array> {\n  let htmlStreamFinished = false\n\n  let pull: Promise<void> | null = null\n  let donePulling = false\n\n  function startOrContinuePulling(\n    controller: TransformStreamDefaultController\n  ) {\n    if (!pull) {\n      pull = startPulling(controller)\n    }\n    return pull\n  }\n\n  async function startPulling(controller: TransformStreamDefaultController) {\n    const reader = stream.getReader()\n\n    if (delayDataUntilFirstHtmlChunk) {\n      // NOTE: streaming flush\n      // We are buffering here for the inlined data stream because the\n      // \"shell\" stream might be chunkenized again by the underlying stream\n      // implementation, e.g. with a specific high-water mark. To ensure it's\n      // the safe timing to pipe the data stream, this extra tick is\n      // necessary.\n\n      // We don't start reading until we've left the current Task to ensure\n      // that it's inserted after flushing the shell. Note that this implementation\n      // might get stale if impl details of Fizz change in the future.\n      await atLeastOneTask()\n    }\n\n    try {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (done) {\n          donePulling = true\n          return\n        }\n\n        // We want to prioritize HTML over RSC data.\n        // The SSR render is based on the same RSC stream, so when we get a new RSC chunk,\n        // we're likely to produce an HTML chunk as well, so give it a chance to flush first.\n        if (!delayDataUntilFirstHtmlChunk && !htmlStreamFinished) {\n          await atLeastOneTask()\n        }\n        controller.enqueue(value)\n      }\n    } catch (err) {\n      controller.error(err)\n    }\n  }\n\n  return new TransformStream({\n    start(controller) {\n      if (!delayDataUntilFirstHtmlChunk) {\n        startOrContinuePulling(controller)\n      }\n    },\n    transform(chunk, controller) {\n      controller.enqueue(chunk)\n\n      // Start the streaming if it hasn't already been started yet.\n      if (delayDataUntilFirstHtmlChunk) {\n        startOrContinuePulling(controller)\n      }\n    },\n    flush(controller) {\n      htmlStreamFinished = true\n      if (donePulling) {\n        return\n      }\n      return startOrContinuePulling(controller)\n    },\n  })\n}\n\nconst CLOSE_TAG = '</body></html>'\n\n/**\n * This transform stream moves the suffix to the end of the stream, so results\n * like `</body></html><script>...</script>` will be transformed to\n * `<script>...</script></body></html>`.\n */\nfunction createMoveSuffixStream(): TransformStream<Uint8Array, Uint8Array> {\n  let foundSuffix = false\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      if (foundSuffix) {\n        return controller.enqueue(chunk)\n      }\n\n      const index = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.BODY_AND_HTML)\n      if (index > -1) {\n        foundSuffix = true\n\n        // If the whole chunk is the suffix, then don't write anything, it will\n        // be written in the flush.\n        if (chunk.length === ENCODED_TAGS.CLOSED.BODY_AND_HTML.length) {\n          return\n        }\n\n        // Write out the part before the suffix.\n        const before = chunk.slice(0, index)\n        controller.enqueue(before)\n\n        // In the case where the suffix is in the middle of the chunk, we need\n        // to split the chunk into two parts.\n        if (chunk.length > ENCODED_TAGS.CLOSED.BODY_AND_HTML.length + index) {\n          // Write out the part after the suffix.\n          const after = chunk.slice(\n            index + ENCODED_TAGS.CLOSED.BODY_AND_HTML.length\n          )\n          controller.enqueue(after)\n        }\n      } else {\n        controller.enqueue(chunk)\n      }\n    },\n    flush(controller) {\n      // Even if we didn't find the suffix, the HTML is not valid if we don't\n      // add it, so insert it at the end.\n      controller.enqueue(ENCODED_TAGS.CLOSED.BODY_AND_HTML)\n    },\n  })\n}\n\nfunction createStripDocumentClosingTagsTransform(): TransformStream<\n  Uint8Array,\n  Uint8Array\n> {\n  return new TransformStream({\n    transform(chunk, controller) {\n      // We rely on the assumption that chunks will never break across a code unit.\n      // This is reasonable because we currently concat all of React's output from a single\n      // flush into one chunk before streaming it forward which means the chunk will represent\n      // a single coherent utf-8 string. This is not safe to use if we change our streaming to no\n      // longer do this large buffered chunk\n      if (\n        isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.BODY_AND_HTML) ||\n        isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.BODY) ||\n        isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.HTML)\n      ) {\n        // the entire chunk is the closing tags; return without enqueueing anything.\n        return\n      }\n\n      // We assume these tags will go at together at the end of the document and that\n      // they won't appear anywhere else in the document. This is not really a safe assumption\n      // but until we revamp our streaming infra this is a performant way to string the tags\n      chunk = removeFromUint8Array(chunk, ENCODED_TAGS.CLOSED.BODY)\n      chunk = removeFromUint8Array(chunk, ENCODED_TAGS.CLOSED.HTML)\n\n      controller.enqueue(chunk)\n    },\n  })\n}\n\n/*\n * Checks if the root layout is missing the html or body tags\n * and if so, it will inject a script tag to throw an error in the browser, showing the user\n * the error message in the error overlay.\n */\nexport function createRootLayoutValidatorStream(): TransformStream<\n  Uint8Array,\n  Uint8Array\n> {\n  let foundHtml = false\n  let foundBody = false\n  return new TransformStream({\n    async transform(chunk, controller) {\n      // Peek into the streamed chunk to see if the tags are present.\n      if (\n        !foundHtml &&\n        indexOfUint8Array(chunk, ENCODED_TAGS.OPENING.HTML) > -1\n      ) {\n        foundHtml = true\n      }\n\n      if (\n        !foundBody &&\n        indexOfUint8Array(chunk, ENCODED_TAGS.OPENING.BODY) > -1\n      ) {\n        foundBody = true\n      }\n\n      controller.enqueue(chunk)\n    },\n    flush(controller) {\n      const missingTags: ('html' | 'body')[] = []\n      if (!foundHtml) missingTags.push('html')\n      if (!foundBody) missingTags.push('body')\n\n      if (!missingTags.length) return\n\n      controller.enqueue(\n        encoder.encode(\n          `<html id=\"__next_error__\">\n            <template\n              data-next-error-message=\"Missing ${missingTags\n                .map((c) => `<${c}>`)\n                .join(\n                  missingTags.length > 1 ? ' and ' : ''\n                )} tags in the root layout.\\nRead more at https://nextjs.org/docs/messages/missing-root-layout-tags\"\n              data-next-error-digest=\"${MISSING_ROOT_TAGS_ERROR}\"\n              data-next-error-stack=\"\"\n            ></template>\n          `\n        )\n      )\n    },\n  })\n}\n\nfunction chainTransformers<T>(\n  readable: ReadableStream<T>,\n  transformers: ReadonlyArray<TransformStream<T, T> | null>\n): ReadableStream<T> {\n  let stream = readable\n  for (const transformer of transformers) {\n    if (!transformer) continue\n\n    stream = stream.pipeThrough(transformer)\n  }\n  return stream\n}\n\nexport type ContinueStreamOptions = {\n  inlinedDataStream: ReadableStream<Uint8Array> | undefined\n  isStaticGeneration: boolean\n  isBuildTimePrerendering: boolean\n  buildId: string\n  getServerInsertedHTML: () => Promise<string>\n  getServerInsertedMetadata: () => Promise<string>\n  validateRootLayout?: boolean\n  /**\n   * Suffix to inject after the buffered data, but before the close tags.\n   */\n  suffix?: string | undefined\n}\n\nexport async function continueFizzStream(\n  renderStream: ReactDOMServerReadableStream,\n  {\n    suffix,\n    inlinedDataStream,\n    isStaticGeneration,\n    isBuildTimePrerendering,\n    buildId,\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n    validateRootLayout,\n  }: ContinueStreamOptions\n): Promise<ReadableStream<Uint8Array>> {\n  // Suffix itself might contain close tags at the end, so we need to split it.\n  const suffixUnclosed = suffix ? suffix.split(CLOSE_TAG, 1)[0] : null\n\n  // If we're generating static HTML we need to wait for it to resolve before continuing.\n  if (isStaticGeneration) {\n    await renderStream.allReady\n  }\n\n  return chainTransformers(renderStream, [\n    // Buffer everything to avoid flushing too frequently\n    createBufferedTransformStream(),\n\n    // Add build id comment to start of the HTML document (in export mode)\n    createPrefetchCommentStream(isBuildTimePrerendering, buildId),\n\n    // Transform metadata\n    createMetadataTransformStream(getServerInsertedMetadata),\n\n    // Insert suffix content\n    suffixUnclosed != null && suffixUnclosed.length > 0\n      ? createDeferredSuffixStream(suffixUnclosed)\n      : null,\n\n    // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n    inlinedDataStream\n      ? createFlightDataInjectionTransformStream(inlinedDataStream, true)\n      : null,\n\n    // Validate the root layout for missing html or body tags\n    validateRootLayout ? createRootLayoutValidatorStream() : null,\n\n    // Close tags should always be deferred to the end\n    createMoveSuffixStream(),\n\n    // Special head insertions\n    // TODO-APP: Insert server side html to end of head in app layout rendering, to avoid\n    // hydration errors. Remove this once it's ready to be handled by react itself.\n    createHeadInsertionTransformStream(getServerInsertedHTML),\n  ])\n}\n\ntype ContinueDynamicPrerenderOptions = {\n  getServerInsertedHTML: () => Promise<string>\n  getServerInsertedMetadata: () => Promise<string>\n}\n\nexport async function continueDynamicPrerender(\n  prerenderStream: ReadableStream<Uint8Array>,\n  {\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n  }: ContinueDynamicPrerenderOptions\n) {\n  return (\n    prerenderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      .pipeThrough(createStripDocumentClosingTagsTransform())\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n      // Transform metadata\n      .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))\n  )\n}\n\ntype ContinueStaticPrerenderOptions = {\n  inlinedDataStream: ReadableStream<Uint8Array>\n  getServerInsertedHTML: () => Promise<string>\n  getServerInsertedMetadata: () => Promise<string>\n  isBuildTimePrerendering: boolean\n  buildId: string\n}\n\nexport async function continueStaticPrerender(\n  prerenderStream: ReadableStream<Uint8Array>,\n  {\n    inlinedDataStream,\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n    isBuildTimePrerendering,\n    buildId,\n  }: ContinueStaticPrerenderOptions\n) {\n  return (\n    prerenderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      // Add build id comment to start of the HTML document (in export mode)\n      .pipeThrough(\n        createPrefetchCommentStream(isBuildTimePrerendering, buildId)\n      )\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n      // Transform metadata\n      .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))\n      // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n      .pipeThrough(\n        createFlightDataInjectionTransformStream(inlinedDataStream, true)\n      )\n      // Close tags should always be deferred to the end\n      .pipeThrough(createMoveSuffixStream())\n  )\n}\n\ntype ContinueResumeOptions = {\n  inlinedDataStream: ReadableStream<Uint8Array>\n  getServerInsertedHTML: () => Promise<string>\n  getServerInsertedMetadata: () => Promise<string>\n  delayDataUntilFirstHtmlChunk: boolean\n}\n\nexport async function continueDynamicHTMLResume(\n  renderStream: ReadableStream<Uint8Array>,\n  {\n    delayDataUntilFirstHtmlChunk,\n    inlinedDataStream,\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n  }: ContinueResumeOptions\n) {\n  return (\n    renderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n      // Transform metadata\n      .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))\n      // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n      .pipeThrough(\n        createFlightDataInjectionTransformStream(\n          inlinedDataStream,\n          delayDataUntilFirstHtmlChunk\n        )\n      )\n      // Close tags should always be deferred to the end\n      .pipeThrough(createMoveSuffixStream())\n  )\n}\n\nexport function createDocumentClosingStream(): ReadableStream<Uint8Array> {\n  return streamFromString(CLOSE_TAG)\n}\n","/**\n * For a given page path, this function ensures that there is a leading slash.\n * If there is not a leading slash, one is added, otherwise it is noop.\n */\nexport function ensureLeadingSlash(path: string) {\n  return path.startsWith('/') ? path : `/${path}`\n}\n","import type { Segment } from '../../server/app-render/types'\n\nexport function isGroupSegment(segment: string) {\n  // Use array[0] for performant purpose\n  return segment[0] === '(' && segment.endsWith(')')\n}\n\nexport function isParallelRouteSegment(segment: string) {\n  return segment.startsWith('@') && segment !== '@children'\n}\n\nexport function addSearchParamsIfPageSegment(\n  segment: Segment,\n  searchParams: Record<string, string | string[] | undefined>\n) {\n  const isPageSegment = segment.includes(PAGE_SEGMENT_KEY)\n\n  if (isPageSegment) {\n    const stringifiedQuery = JSON.stringify(searchParams)\n    return stringifiedQuery !== '{}'\n      ? PAGE_SEGMENT_KEY + '?' + stringifiedQuery\n      : PAGE_SEGMENT_KEY\n  }\n\n  return segment\n}\n\nexport const PAGE_SEGMENT_KEY = '__PAGE__'\nexport const DEFAULT_SEGMENT_KEY = '__DEFAULT__'\n","import { ensureLeadingSlash } from '../../page-path/ensure-leading-slash'\nimport { isGroupSegment } from '../../segment'\n\n/**\n * Normalizes an app route so it represents the actual request path. Essentially\n * performing the following transformations:\n *\n * - `/(dashboard)/user/[id]/page` to `/user/[id]`\n * - `/(dashboard)/account/page` to `/account`\n * - `/user/[id]/page` to `/user/[id]`\n * - `/account/page` to `/account`\n * - `/page` to `/`\n * - `/(dashboard)/user/[id]/route` to `/user/[id]`\n * - `/(dashboard)/account/route` to `/account`\n * - `/user/[id]/route` to `/user/[id]`\n * - `/account/route` to `/account`\n * - `/route` to `/`\n * - `/` to `/`\n *\n * @param route the app route to normalize\n * @returns the normalized pathname\n */\nexport function normalizeAppPath(route: string) {\n  return ensureLeadingSlash(\n    route.split('/').reduce((pathname, segment, index, segments) => {\n      // Empty segments are ignored.\n      if (!segment) {\n        return pathname\n      }\n\n      // Groups are ignored.\n      if (isGroupSegment(segment)) {\n        return pathname\n      }\n\n      // Parallel segments are ignored.\n      if (segment[0] === '@') {\n        return pathname\n      }\n\n      // The last segment (if it's a leaf) should be ignored.\n      if (\n        (segment === 'page' || segment === 'route') &&\n        index === segments.length - 1\n      ) {\n        return pathname\n      }\n\n      return `${pathname}/${segment}`\n    }, '')\n  )\n}\n\n/**\n * Strips the `.rsc` extension if it's in the pathname.\n * Since this function is used on full urls it checks `?` for searchParams handling.\n */\nexport function normalizeRscURL(url: string) {\n  return url.replace(\n    /\\.rsc($|\\?)/,\n    // $1 ensures `?` is preserved\n    '$1'\n  )\n}\n"],"names":["AppRenderSpan","AppRouteRouteHandlersSpan","BaseServerSpan","LoadComponentsSpan","LogSpanAllowList","MiddlewareSpan","NextNodeServerSpan","NextServerSpan","NextVanillaSpanAllowlist","NodeSpan","RenderSpan","ResolveMetadataSpan","RouterSpan","StartServerSpan","isThenable","promise","then","BubbledError","SpanKind","SpanStatusCode","getTracer","isBubbledError","api","process","env","NEXT_RUNTIME","require","err","context","propagation","trace","ROOT_CONTEXT","Error","constructor","bubble","result","error","closeSpanWithError","span","setAttribute","recordException","name","setStatus","code","ERROR","message","end","rootSpanAttributesStore","Map","rootSpanIdKey","createContextKey","lastSpanId","getSpanId","clientTraceDataSetter","set","carrier","key","value","push","NextTracerImpl","getTracerInstance","getContext","getTracePropagationData","activeContext","active","entries","inject","getActiveScopeSpan","getSpan","withPropagatedContext","fn","getter","getSpanContext","remoteContext","extract","with","args","type","fnOrOptions","fnOrEmpty","options","spanName","includes","NEXT_OTEL_VERBOSE","hideSpan","spanContext","parentSpan","isRootSpan","isRemote","spanId","attributes","setValue","startActiveSpan","startTime","globalThis","performance","now","undefined","onCleanup","delete","NEXT_OTEL_PERFORMANCE_PREFIX","measure","split","pop","replace","match","toLowerCase","start","Object","length","res","catch","finally","wrap","tracer","optionsObj","apply","arguments","lastArgId","cb","scopeBoundCb","bind","_span","done","startSpan","setSpan","getRootSpanAttributes","getValue","get","setRootSpanAttribute","DynamicServerError","isDynamicServerError","DYNAMIC_ERROR_CODE","description","digest","StaticGenBailoutError","isStaticGenBailoutError","NEXT_STATIC_GEN_BAILOUT","isHangingPromiseRejectionError","makeDevtoolsIOAwarePromise","makeHangingPromise","HANGING_PROMISE_REJECTION","HangingPromiseRejectionError","route","expression","abortListenersBySignal","WeakMap","signal","aborted","Promise","reject","hangingPromise","_","boundRejection","currentListeners","listeners","addEventListener","i","once","ignoreReject","underlying","resolve","setTimeout","METADATA_BOUNDARY_NAME","OUTLET_BOUNDARY_NAME","ROOT_LAYOUT_BOUNDARY_NAME","VIEWPORT_BOUNDARY_NAME","atLeastOneTask","scheduleImmediate","scheduleOnNextTick","waitAtLeastOneReactRenderTask","nextTick","setImmediate","r","BailoutToCSRError","isBailoutToCSRError","BAILOUT_TO_CSR","reason","InvariantError","endsWith","Postpone","PreludeState","abortAndThrowOnSynchronousRequestDataAccess","abortOnSynchronousPlatformIOAccess","accessedDynamicData","annotateDynamicAccess","consumeDynamicAccess","createDynamicTrackingState","createDynamicValidationState","createHangingInputAbortSignal","createRenderInBrowserAbortSignal","delayUntilRuntimeStage","formatDynamicAPIAccesses","getFirstDynamicReason","isDynamicPostpone","isPrerenderInterruptedError","logDisallowedDynamicError","markCurrentScopeAsDynamic","postponeWithTracking","throwIfDisallowedDynamic","throwToInterruptStaticGeneration","trackAllowedDynamicAccess","trackDynamicDataInDynamicRender","trackSynchronousPlatformIOAccessInDev","trackSynchronousRequestDataAccessInDev","useDynamicRouteParams","warnOnSyncDynamicError","hasPostpone","React","unstable_postpone","isDebugDynamicAccesses","dynamicAccesses","syncDynamicErrorWithStack","hasSuspenseAboveBody","hasDynamicMetadata","hasDynamicViewport","hasAllowedDynamic","dynamicErrors","trackingState","store","workUnitStore","forceDynamic","forceStatic","dynamicShouldError","dynamicTracking","revalidate","dynamicUsageDescription","dynamicUsageStack","stack","NODE_ENV","usedDynamic","prerenderStore","abortOnSynchronousDynamicDataAccess","createPrerenderInterruptedError","controller","abort","errorWithStack","requestStore","prerenderPhase","prerenderSignal","console","workUnitAsyncStorage","getStore","assertPostpone","createPostponeReason","isDynamicPostponeReason","NEXT_PRERENDER_INTERRUPTED","serverDynamic","clientDynamic","filter","access","map","slice","line","join","AbortController","cacheSignal","inputReady","runtimeStagePromise","getRuntimeStagePromise","workStore","workAsyncStorage","fallbackParams","fallbackRouteParams","size","use","renderSignal","hasSuspenseRegex","bodyAndImplicitTags","hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex","RegExp","hasMetadataRegex","hasViewportRegex","hasOutletRegex","componentStack","dynamicValidation","test","createErrorWithComponentOrOwnerStack","ownerStack","captureOwnerStack","dev","hasReadableErrorStacks","prelude","DetachedPromise","rej","ENCODED_TAGS","OPENING","HTML","Uint8Array","BODY","CLOSED","HEAD","BODY_AND_HTML","META","ICON_MARK","indexOfUint8Array","isEquivalentUint8Arrays","removeFromUint8Array","a","b","completeMatch","j","tagIndex","subarray","removed","MISSING_ROOT_TAGS_ERROR","DOC_PREFETCH_RANGE_HEADER_VALUE","doesExportedHtmlMatchBuildId","insertBuildIdComment","DOCTYPE_PREFIX","MAX_BUILD_ID_LENGTH","escapeBuildId","buildId","truncated","originalHtml","startsWith","partialHtmlDocument","chainStreams","continueDynamicHTMLResume","continueDynamicPrerender","continueFizzStream","continueStaticPrerender","createBufferedTransformStream","createDocumentClosingStream","createRootLayoutValidatorStream","renderToInitialFizzStream","streamFromBuffer","streamFromString","streamToBuffer","streamToString","voidCatch","encoder","TextEncoder","streams","ReadableStream","close","readable","writable","TransformStream","pipeTo","preventClose","nextStream","lastStream","str","enqueue","encode","chunk","stream","reader","getReader","chunks","read","Buffer","concat","decoder","TextDecoder","fatal","string","decode","bufferedChunks","bufferByteLength","pending","flush","detached","copiedBytes","bufferedChunk","byteLength","transform","createPrefetchCommentStream","isBuildTimePrerendering","didTransformFirstChunk","chunkStr","updatedChunkStr","ReactDOMServer","element","streamOptions","renderToReadableStream","createMetadataTransformStream","insert","chunkIndex","isMarkRemoved","iconMarkIndex","closedHeadIndex","iconMarkLength","replaced","insertion","encodedInsertion","insertionLength","createHeadInsertionTransformStream","inserted","hasBytes","index","insertedHeadContent","createDeferredSuffixStream","suffix","flushed","createFlightDataInjectionTransformStream","delayDataUntilFirstHtmlChunk","htmlStreamFinished","pull","donePulling","startOrContinuePulling","startPulling","CLOSE_TAG","createMoveSuffixStream","foundSuffix","before","after","createStripDocumentClosingTagsTransform","foundHtml","foundBody","missingTags","c","chainTransformers","transformers","transformer","pipeThrough","renderStream","inlinedDataStream","isStaticGeneration","getServerInsertedHTML","getServerInsertedMetadata","validateRootLayout","suffixUnclosed","allReady","prerenderStream","ensureLeadingSlash","path","DEFAULT_SEGMENT_KEY","PAGE_SEGMENT_KEY","addSearchParamsIfPageSegment","isGroupSegment","isParallelRouteSegment","segment","searchParams","isPageSegment","stringifiedQuery","JSON","stringify","normalizeAppPath","normalizeRscURL","reduce","pathname","segments","url"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]}